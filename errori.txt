sara@gianni:~/Dropbox/Sistemi operativi/umpsss/examples/phase1$ mipsel-linux-gnu-gcc -ansi -mips1 -mfp32 -std=c99 -I/usr/local/include/umps2 -c pcb.c
pcb.c:22:13: error: static declaration of ‘initPcbs’ follows non-static declaration
 HIDDEN void initPcbs(void){
             ^~~~~~~~
pcb.h:8:6: note: previous declaration of ‘initPcbs’ was here
 HIDDEN void initPcbs(void);
      ^~~~~~~~
pcb.c:31:13: error: static declaration of ‘freePcb’ follows non-static declaration
 HIDDEN void freePcb(pcb_t *p){
             ^~~~~~~
pcb.h:9:6: note: previous declaration of ‘freePcb’ was here
 HIDDEN void freePcb(pcb_t *p);
      ^~~~~~~
pcb.c:37:15: error: static declaration of ‘allocPcb’ follows non-static declaration
 HIDDEN pcb_t *allocPcb(void){
               ^~~~~~~~
pcb.h:10:8: note: previous declaration of ‘allocPcb’ was here
 HIDDEN pcb_t *allocPcb(void);
        ^~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
pcb.c: In function ‘allocPcb’:
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
pcb.c:40:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.prev, pcb_t, p_next); //Restituisce puntatore all'ultimo elemento della pcbFree
                   ^~~~~~~~~~~~
listx.h:32:21: error: ‘__mptr’ undeclared (first use in this function)
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
pcb.c:40:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.prev, pcb_t, p_next); //Restituisce puntatore all'ultimo elemento della pcbFree
                   ^~~~~~~~~~~~
listx.h:32:21: note: each undeclared identifier is reported only once for each function it appears in
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
pcb.c:40:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.prev, pcb_t, p_next); //Restituisce puntatore all'ultimo elemento della pcbFree
                   ^~~~~~~~~~~~
pcb.c:41:18: error: incompatible type for argument 1 of ‘list_del’
  list_del(tempPcb->p_next); //Rimuove tempPcb dalla lista dei pcbFree: NON viene deallocato!
           ~~~~~~~^~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:161:47: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void list_del(struct list_head *entry)
                             ~~~~~~~~~~~~~~~~~~^~~~~
pcb.c:48:9: error: ‘pcb_t’ {aka ‘struct pcb_t’} has no member named ‘p_state’
  tempPcb->p_state = ???
         ^~
pcb.c:48:21: error: expected expression before ‘?’ token
  tempPcb->p_state = ???
                     ^
pcb.c:52:24: error: incompatible type for argument 1 of ‘INIT_LIST_HEAD’
  INIT_LIST_HEAD(tempPcb->p_next);
                 ~~~~~~~^~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:91:53: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void INIT_LIST_HEAD(struct list_head *list)
                                   ~~~~~~~~~~~~~~~~~~^~~~
pcb.c:53:24: error: incompatible type for argument 1 of ‘INIT_LIST_HEAD’
  INIT_LIST_HEAD(tempPcb->p_child);
                 ~~~~~~~^~~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:91:53: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void INIT_LIST_HEAD(struct list_head *list)
                                   ~~~~~~~~~~~~~~~~~~^~~~
pcb.c:54:24: error: incompatible type for argument 1 of ‘INIT_LIST_HEAD’
  INIT_LIST_HEAD(tempPcb->p_sib);
                 ~~~~~~~^~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:91:53: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void INIT_LIST_HEAD(struct list_head *list)
                                   ~~~~~~~~~~~~~~~~~~^~~~
pcb.c: At top level:
pcb.c:64:13: error: static declaration of ‘mkEmptyProcQ’ follows non-static declaration
 HIDDEN void mkEmptyProcQ(struct list_head *head){
             ^~~~~~~~~~~~
pcb.h:13:6: note: previous declaration of ‘mkEmptyProcQ’ was here
 HIDDEN void mkEmptyProcQ(struct list_head *head);
      ^~~~~~~~~~~~
pcb.c:71:12: error: static declaration of ‘emptyProcQ’ follows non-static declaration
 HIDDEN int emptyProcQ(struct list_head *head){
            ^~~~~~~~~~
pcb.h:14:5: note: previous declaration of ‘emptyProcQ’ was here
 HIDDEN int emptyProcQ(struct list_head *head);
     ^~~~~~~~~~
pcb.c:79:13: error: static declaration of ‘insertProcQ’ follows non-static declaration
 HIDDEN void insertProcQ(struct list_head *head, pcb_t *p){
             ^~~~~~~~~~~
pcb.h:15:6: note: previous declaration of ‘insertProcQ’ was here
 HIDDEN void insertProcQ(struct list_head *head, pcb_t *p);
      ^~~~~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
pcb.c: In function ‘insertProcQ’:
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
listx.h:263:13: note: in expansion of macro ‘container_of’
  for (pos = container_of((head)->next, typeof(*pos), member);      \
             ^~~~~~~~~~~~
pcb.c:81:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:263:40: warning: implicit declaration of function ‘typeof’ [-Wimplicit-function-declaration]
  for (pos = container_of((head)->next, typeof(*pos), member);      \
                                        ^~~~~~
listx.h:32:4: note: in definition of macro ‘container_of’
   (type *)( (char *)__mptr - offsetof(type,member) );})
    ^~~~
pcb.c:81:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:32:10: error: expected expression before ‘)’ token
   (type *)( (char *)__mptr - offsetof(type,member) );})
          ^
listx.h:263:13: note: in expansion of macro ‘container_of’
  for (pos = container_of((head)->next, typeof(*pos), member);      \
             ^~~~~~~~~~~~
pcb.c:81:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:32:21: error: ‘__mptr’ undeclared (first use in this function)
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
listx.h:263:13: note: in expansion of macro ‘container_of’
  for (pos = container_of((head)->next, typeof(*pos), member);      \
             ^~~~~~~~~~~~
pcb.c:81:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
listx.h:265:8: note: in expansion of macro ‘container_of’
  pos = container_of(pos->member.next, typeof(*pos), member))
        ^~~~~~~~~~~~
pcb.c:81:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:32:10: error: expected expression before ‘)’ token
   (type *)( (char *)__mptr - offsetof(type,member) );})
          ^
listx.h:265:8: note: in expansion of macro ‘container_of’
  pos = container_of(pos->member.next, typeof(*pos), member))
        ^~~~~~~~~~~~
pcb.c:81:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
pcb.c:83:42: error: incompatible type for argument 1 of ‘list_prev’
    __list_add(&(p->p_next), &(list_prev(i->p_next)), &(i->p_next)); //inserisco p nella lista head tra prev di i e i
                                         ~^~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:216:67: note: expected ‘const struct list_head *’ but argument is of type ‘struct list_head’
 static inline struct list_head *list_prev(const struct list_head *current)
                                           ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
pcb.c: At top level:
pcb.c:94:15: error: static declaration of ‘headProcQ’ follows non-static declaration
 HIDDEN pcb_t *headProcQ(struct list_head *head){
               ^~~~~~~~~
pcb.h:16:8: note: previous declaration of ‘headProcQ’ was here
 HIDDEN pcb_t *headProcQ(struct list_head *head);
        ^~~~~~~~~
pcb.c: In function ‘headProcQ’:
pcb.c:95:5: error: expected ‘(’ before ‘list_empty’
  if list_empty(head)
     ^~~~~~~~~~
     (
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
pcb.c:98:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.next, pcb_t, p_next); //Restituisce puntatore al primo elemento della pcbFree (non lo rimuove!)
                   ^~~~~~~~~~~~
listx.h:32:21: error: ‘__mptr’ undeclared (first use in this function)
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
pcb.c:98:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.next, pcb_t, p_next); //Restituisce puntatore al primo elemento della pcbFree (non lo rimuove!)
                   ^~~~~~~~~~~~
pcb.c: At top level:
pcb.c:104:15: error: static declaration of ‘removeProcQ’ follows non-static declaration
 HIDDEN pcb_t *removeProcQ(struct list_head *head){
               ^~~~~~~~~~~
pcb.h:18:8: note: previous declaration of ‘removeProcQ’ was here
 HIDDEN pcb_t *removeProcQ(struct list_head *head);
        ^~~~~~~~~~~
pcb.c: In function ‘removeProcQ’:
pcb.c:105:5: error: expected ‘(’ before ‘list_empty’
  if list_empty(head)
     ^~~~~~~~~~
     (
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
pcb.c:108:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.next, pcb_t, p_next); //Restituisce puntatore al primo elemento della pcbFree (non lo rimuove!)
                   ^~~~~~~~~~~~
listx.h:32:21: error: ‘__mptr’ undeclared (first use in this function)
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
pcb.c:108:19: note: in expansion of macro ‘container_of’
  pcb_t* tempPcb = container_of(pcbFree_h.next, pcb_t, p_next); //Restituisce puntatore al primo elemento della pcbFree (non lo rimuove!)
                   ^~~~~~~~~~~~
pcb.c: At top level:
pcb.c:116:15: error: static declaration of ‘outProcQ’ follows non-static declaration
 HIDDEN pcb_t *outProcQ(struct list_head *head, pcb_t *p){
               ^~~~~~~~
pcb.h:19:8: note: previous declaration of ‘outProcQ’ was here
 HIDDEN pcb_t *outProcQ(struct list_head *head, pcb_t *p);
        ^~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
pcb.c: In function ‘outProcQ’:
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
listx.h:263:13: note: in expansion of macro ‘container_of’
  for (pos = container_of((head)->next, typeof(*pos), member);      \
             ^~~~~~~~~~~~
pcb.c:118:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:32:10: error: expected expression before ‘)’ token
   (type *)( (char *)__mptr - offsetof(type,member) );})
          ^
listx.h:263:13: note: in expansion of macro ‘container_of’
  for (pos = container_of((head)->next, typeof(*pos), member);      \
             ^~~~~~~~~~~~
pcb.c:118:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:32:21: error: ‘__mptr’ undeclared (first use in this function)
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
listx.h:263:13: note: in expansion of macro ‘container_of’
  for (pos = container_of((head)->next, typeof(*pos), member);      \
             ^~~~~~~~~~~~
pcb.c:118:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
listx.h:265:8: note: in expansion of macro ‘container_of’
  pos = container_of(pos->member.next, typeof(*pos), member))
        ^~~~~~~~~~~~
pcb.c:118:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
listx.h:32:10: error: expected expression before ‘)’ token
   (type *)( (char *)__mptr - offsetof(type,member) );})
          ^
listx.h:265:8: note: in expansion of macro ‘container_of’
  pos = container_of(pos->member.next, typeof(*pos), member))
        ^~~~~~~~~~~~
pcb.c:118:2: note: in expansion of macro ‘list_for_each_entry’
  list_for_each_entry(i, head, p_next){
  ^~~~~~~~~~~~~~~~~~~
pcb.c: At top level:
pcb.c:132:12: error: static declaration of ‘emptyChild’ follows non-static declaration
 HIDDEN int emptyChild(pcb_t *this){
            ^~~~~~~~~~
pcb.h:23:5: note: previous declaration of ‘emptyChild’ was here
 HIDDEN int emptyChild(pcb_t *this);
     ^~~~~~~~~~
pcb.c: In function ‘emptyChild’:
pcb.c:133:24: error: incompatible type for argument 1 of ‘list_empty’
  return list_empty(this->p_child); //TRUE se p_child è vuota, FALSE altrimenti
                    ~~~~^~~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:187:54: note: expected ‘const struct list_head *’ but argument is of type ‘struct list_head’
 static inline int list_empty(const struct list_head *head)
                              ~~~~~~~~~~~~~~~~~~~~~~~~^~~~
pcb.c: At top level:
pcb.c:137:13: error: static declaration of ‘insertChild’ follows non-static declaration
 HIDDEN void insertChild(pcb_t *prnt, pcb_t *p){
             ^~~~~~~~~~~
pcb.h:24:6: note: previous declaration of ‘insertChild’ was here
 HIDDEN void insertChild(pcb_t *prnt, pcb_t *p);
      ^~~~~~~~~~~
pcb.c:144:15: error: static declaration of ‘removeChild’ follows non-static declaration
 HIDDEN pcb_t *removeChild(pcb_t *p){
               ^~~~~~~~~~~
pcb.h:25:8: note: previous declaration of ‘removeChild’ was here
 HIDDEN pcb_t *removeChild(pcb_t *p);
        ^~~~~~~~~~~
pcb.c: In function ‘removeChild’:
pcb.c:148:3: error: unknown type name ‘list_head’; use ‘struct’ keyword to refer to the type
   list_head *list_primofiglio = list_next(p->p_child); //Primo figlio: è il next della sentinella (che punta a p_sib del primo figlio)
   ^~~~~~~~~
   struct 
pcb.c:148:44: error: incompatible type for argument 1 of ‘list_next’
   list_head *list_primofiglio = list_next(p->p_child); //Primo figlio: è il next della sentinella (che punta a p_sib del primo figlio)
                                           ~^~~~~~~~~
In file included from types_rikaya.h:5,
                 from pcb.h:4:
listx.h:200:67: note: expected ‘const struct list_head *’ but argument is of type ‘struct list_head’
 static inline struct list_head *list_next(const struct list_head *current)
                                           ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
listx.h:31:17: error: expected declaration specifiers or ‘...’ before ‘(’ token
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                 ^
pcb.c:150:24: note: in expansion of macro ‘container_of’
   pcb_t *primofiglio = container_of(list_primofiglio, pcb_t, p_sib); //Ho il pcb del primo figlio
                        ^~~~~~~~~~~~
listx.h:32:21: error: ‘__mptr’ undeclared (first use in this function)
   (type *)( (char *)__mptr - offsetof(type,member) );})
                     ^~~~~~
pcb.c:150:24: note: in expansion of macro ‘container_of’
   pcb_t *primofiglio = container_of(list_primofiglio, pcb_t, p_sib); //Ho il pcb del primo figlio
                        ^~~~~~~~~~~~
pcb.c: At top level:
pcb.c:159:15: error: static declaration of ‘outChild’ follows non-static declaration
 HIDDEN pcb_t *outChild(pcb_t *p){
               ^~~~~~~~
pcb.h:26:8: note: previous declaration of ‘outChild’ was here
 HIDDEN pcb_t *outChild(pcb_t *p);
        ^~~~~~~~
