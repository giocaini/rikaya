sara@gianni:~/Dropbox/Sistemi operativi/umpsss/examples/phase1$ mipsel-linux-gnu-gcc -ansi -mips1 -mfp32 -std=gnu11 -I/usr/local/include/umps2 -c pcb.c
pcb.c: In function ‘allocPcb’:
pcb.c:60:24: error: incompatible type for argument 1 of ‘INIT_LIST_HEAD’
  INIT_LIST_HEAD(tempPcb->p_next);
                 ~~~~~~~^~~~~~~~
In file included from pcb.c:9:
listx.h:91:53: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void INIT_LIST_HEAD(struct list_head *list)
                                   ~~~~~~~~~~~~~~~~~~^~~~
pcb.c:61:24: error: incompatible type for argument 1 of ‘INIT_LIST_HEAD’
  INIT_LIST_HEAD(tempPcb->p_child);
                 ~~~~~~~^~~~~~~~~
In file included from pcb.c:9:
listx.h:91:53: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void INIT_LIST_HEAD(struct list_head *list)
                                   ~~~~~~~~~~~~~~~~~~^~~~
pcb.c:62:24: error: incompatible type for argument 1 of ‘INIT_LIST_HEAD’
  INIT_LIST_HEAD(tempPcb->p_sib);
                 ~~~~~~~^~~~~~~
In file included from pcb.c:9:
listx.h:91:53: note: expected ‘struct list_head *’ but argument is of type ‘struct list_head’
 static inline void INIT_LIST_HEAD(struct list_head *list)
                                   ~~~~~~~~~~~~~~~~~~^~~~
pcb.c: In function ‘insertProcQ’:
pcb.c:91:42: error: incompatible type for argument 1 of ‘list_prev’
    __list_add(&(p->p_next), &(list_prev(i->p_next)), &(i->p_next)); //inserisco p nella lista head tra prev di i e i
                                         ~^~~~~~~~
In file included from pcb.c:9:
listx.h:216:67: note: expected ‘const struct list_head *’ but argument is of type ‘struct list_head’
 static inline struct list_head *list_prev(const struct list_head *current)
                                           ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
pcb.c: In function ‘headProcQ’:
pcb.c:103:5: error: expected ‘(’ before ‘list_empty’
  if list_empty(head)
     ^~~~~~~~~~
     (
pcb.c: In function ‘removeProcQ’:
pcb.c:113:5: error: expected ‘(’ before ‘list_empty’
  if list_empty(head)
     ^~~~~~~~~~
     (
pcb.c: In function ‘emptyChild’:
pcb.c:141:24: error: incompatible type for argument 1 of ‘list_empty’
  return list_empty(this->p_child); //TRUE se p_child è vuota, FALSE altrimenti
                    ~~~~^~~~~~~~~
In file included from pcb.c:9:
listx.h:187:54: note: expected ‘const struct list_head *’ but argument is of type ‘struct list_head’
 static inline int list_empty(const struct list_head *head)
                              ~~~~~~~~~~~~~~~~~~~~~~~~^~~~
pcb.c: In function ‘removeChild’:
pcb.c:156:3: error: unknown type name ‘list_head’; use ‘struct’ keyword to refer to the type
   list_head *list_primofiglio = list_next(p->p_child); //Primo figlio: è il next della sentinella (che punta a p_sib del primo figlio)
   ^~~~~~~~~
   struct 
pcb.c:156:44: error: incompatible type for argument 1 of ‘list_next’
   list_head *list_primofiglio = list_next(p->p_child); //Primo figlio: è il next della sentinella (che punta a p_sib del primo figlio)
                                           ~^~~~~~~~~
In file included from pcb.c:9:
listx.h:200:67: note: expected ‘const struct list_head *’ but argument is of type ‘struct list_head’
 static inline struct list_head *list_next(const struct list_head *current)
                                           ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
listx.h:31:49: warning: initialization of ‘const struct list_head *’ from incompatible pointer type ‘int *’ [-Wincompatible-pointer-types]
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                                                 ^
pcb.c:158:24: note: in expansion of macro ‘container_of’
   pcb_t *primofiglio = container_of(list_primofiglio, pcb_t, p_sib); //Ho il pcb del primo figlio
                        ^~~~~~~~~~~~
listx.h:31:49: note: (near initialization for ‘primofiglio’)
   const typeof( ((type *)0)->member ) *__mptr = (ptr); \
                                                 ^
pcb.c:158:24: note: in expansion of macro ‘container_of’
   pcb_t *primofiglio = container_of(list_primofiglio, pcb_t, p_sib); //Ho il pcb del primo figlio
                        ^~~~~~~~~~~~
